<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pokémon Filter</title>
  <!-- your styles here (keep what you have) -->
</head>
<body>
  <!-- Your form here, same as you have, but remove method="POST" -->

  <form id="pokemonForm">
    <!-- all your form inputs/selects here -->
    <button type="submit">Search</button>
  </form>

  <div id="resultsContainer"></div>

  <textarea id="showdownExportBox" rows="10" cols="50" readonly style="display:none;"></textarea>
  <button id="copyButton" style="display:none;">Copy to Clipboard</button>

  <script>
    const REGION_DEX_RANGES = {
      kanto: [1, 151],
      johto: [152, 251],
      hoenn: [252, 386],
      sinnoh: [387, 493],
      unova: [494, 649],
      kalos: [650, 721],
      alola: [722, 809],
      galar: [810, 898],
      paldea: [899, 1025],
      blueberry: [/* list of dex numbers here or simplified */],
      all: [1, 1025]
    };

    // Your form handler:
    document.getElementById('pokemonForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const form = e.target;

      // Get form values
      const pokeType = form.type.value.toLowerCase();
      const region = form.region.value.toLowerCase();
      const fullyEvolved = form.evolved.value === "yes";
      const minBst = Number(form.min_bst.value) || 0;
      const maxBst = Number(form.max_bst.value) || 2000;
      const numRandom = Number(form.num_random.value) || 6;
      const randomMoves = form.random_moves.value === "on";

      const dexRange = REGION_DEX_RANGES[region] || [1, 1025];
      const dexStart = dexRange[0];
      const dexEnd = dexRange[1];

      const resultsContainer = document.getElementById('resultsContainer');
      resultsContainer.innerHTML = "Loading...";

      const teraTypes = [
        "normal", "fire", "water", "electric", "grass", "ice", "fighting", "poison", 
        "ground", "flying", "psychic", "bug", "rock", "ghost", "dragon", "dark", 
        "steel", "fairy"
      ];

      // Helper: fetch pokemon data from PokéAPI by dex number
      async function fetchPokemonData(dex) {
        try {
          const res = await fetch(`https://pokeapi.co/api/v2/pokemon/${dex}`);
          if (!res.ok) return null;
          const data = await res.json();
          return data;
        } catch {
          return null;
        }
      }

      // Helper: check if fully evolved by checking evolution chain length
      async function isFullyEvolved(pokemonName) {
        try {
          const speciesRes = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${pokemonName}`);
          const speciesData = await speciesRes.json();
          const evoChainRes = await fetch(speciesData.evolution_chain.url);
          const evoChain = await evoChainRes.json();

          function findFinal(chain) {
            if (!chain.evolves_to.length) {
              return [chain.species.name];
            }
            let final = [];
            chain.evolves_to.forEach(evo => {
              final = final.concat(findFinal(evo));
            });
            return final;
          }

          const finals = findFinal(evoChain.chain);
          return finals.includes(pokemonName);
        } catch {
          return false;
        }
      }

      // Collect matching Pokémon
      let matching = [];
      for (let dex = dexStart; dex <= dexEnd; dex++) {
        const pokeData = await fetchPokemonData(dex);
        if (!pokeData) continue;

        // Type filter
        const types = pokeData.types.map(t => t.type.name);
        if (pokeType !== "all" && !types.includes(pokeType)) continue;

        // Fully evolved filter
        if (fullyEvolved) {
          const evolved = await isFullyEvolved(pokeData.name);
          if (!evolved) continue;
        }

        // Calculate BST
        const stats = pokeData.stats;
        const bst = stats.reduce((acc, stat) => acc + stat.base_stat, 0);
        if (bst < minBst || bst > maxBst) continue;

        // Pick random ability
        const abilities = pokeData.abilities.map(a => a.ability.name);
        const randomAbility = abilities[Math.floor(Math.random() * abilities.length)];

        // Random tera type
        const randomTeraType = teraTypes[Math.floor(Math.random() * teraTypes.length)];

        // Moves from the move list (filter for generation 9 move versions if needed)
        let moves = [];
        if (randomMoves) {
          const allMoves = pokeData.moves.map(m => m.move.name);
          moves = allMoves.sort(() => 0.5 - Math.random()).slice(0, 4);
        }

        matching.push({
          name: pokeData.name,
          dex: dex,
          types: types.join(", "),
          sprite: pokeData.sprites.front_default,
          moves: moves,
          ability: randomAbility,
          tera_type: randomTeraType
        });
      }

      // Pick random Pokémon from matches
      if (matching.length === 0) {
        resultsContainer.innerHTML = "<p>No Pokémon found with those criteria.</p>";
        return;
      }

      const results = matching.sort(() => 0.5 - Math.random()).slice(0, numRandom);

      // Render results
      resultsContainer.innerHTML = "";
      let showdownExport = "";
      results.forEach(poke => {
        const card = document.createElement('div');
        card.className = "card";

        const h3 = document.createElement('h3');
        h3.textContent = `#${poke.dex} - ${poke.name.charAt(0).toUpperCase() + poke.name.slice(1)}`;
        card.appendChild(h3);

        card.innerHTML += `<p>Types: ${poke.types}</p>`;
        card.innerHTML += `<p>Ability: ${poke.ability.charAt(0).toUpperCase() + poke.ability.slice(1)}</p>`;
        card.innerHTML += `<p>Tera Type: ${poke.tera_type.charAt(0).toUpperCase() + poke.tera_type.slice(1)}</p>`;
        if (poke.sprite) {
          const img = document.createElement('img');
          img.src = poke.sprite;
          img.alt = poke.name;
          card.appendChild(img);
        }

        if (poke.moves.length > 0) {
          const movesDiv = document.createElement('div');
          movesDiv.className = "moves";
          poke.moves.forEach(move => {
            const span = document.createElement('span');
            span.className = "move";
            span.textContent = move;
            movesDiv.appendChild(span);
          });
          card.appendChild(movesDiv);
        } else {
          card.innerHTML += "<p>No random moves available.</p>";
        }

        resultsContainer.appendChild(card);

        // Build showdown export text
        showdownExport += `${poke.name.charAt(0).toUpperCase() + poke.name.slice(1)}\n`;
        showdownExport += `Ability: ${poke.ability.charAt(0).toUpperCase() + poke.ability.slice(1)}\n`;
        showdownExport += `Tera Type: ${poke.tera_type.charAt(0).toUpperCase() + poke.tera_type.slice(1)}\n`;
        if (poke.moves.length > 0) {
          showdownExport += `- ${poke.moves.join("\n- ")}\n\n`;
        } else {
          showdownExport += "\n";
        }
      });

      // Show showdown export textarea and copy button
      const showdownBox = document.getElementById('showdownExportBox');
      showdownBox.style.display = "block";
      showdownBox.value = showdownExport;

      const copyBtn = document.getElementById('copyButton');
      copyBtn.style.display = "inline-block";
      copyBtn.onclick = () => {
        showdownBox.select();
        document.execCommand('copy');
        alert('Copied to clipboard!');
      };
    });

    // Keep your dark mode toggle JS here, unchanged
  </script>
</body>
</html>
